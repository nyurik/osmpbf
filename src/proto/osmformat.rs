// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `osmformat.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:OSMPBF.HeaderBlock)
pub struct HeaderBlock {
    // message fields
    // @@protoc_insertion_point(field:OSMPBF.HeaderBlock.bbox)
    pub bbox: ::protobuf::MessageField<HeaderBBox>,
    // @@protoc_insertion_point(field:OSMPBF.HeaderBlock.required_features)
    pub required_features: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:OSMPBF.HeaderBlock.optional_features)
    pub optional_features: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:OSMPBF.HeaderBlock.writingprogram)
    pub writingprogram: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:OSMPBF.HeaderBlock.source)
    pub source: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:OSMPBF.HeaderBlock.osmosis_replication_timestamp)
    pub osmosis_replication_timestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:OSMPBF.HeaderBlock.osmosis_replication_sequence_number)
    pub osmosis_replication_sequence_number: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:OSMPBF.HeaderBlock.osmosis_replication_base_url)
    pub osmosis_replication_base_url: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:OSMPBF.HeaderBlock.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HeaderBlock {
    fn default() -> &'a HeaderBlock {
        <HeaderBlock as ::protobuf::Message>::default_instance()
    }
}

impl HeaderBlock {
    pub fn new() -> HeaderBlock {
        ::std::default::Default::default()
    }

    // optional string writingprogram = 16;

    pub fn writingprogram(&self) -> &str {
        match self.writingprogram.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_writingprogram(&mut self) {
        self.writingprogram = ::std::option::Option::None;
    }

    pub fn has_writingprogram(&self) -> bool {
        self.writingprogram.is_some()
    }

    // Param is passed by value, moved
    pub fn set_writingprogram(&mut self, v: ::std::string::String) {
        self.writingprogram = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_writingprogram(&mut self) -> &mut ::std::string::String {
        if self.writingprogram.is_none() {
            self.writingprogram = ::std::option::Option::Some(::std::string::String::new());
        }
        self.writingprogram.as_mut().unwrap()
    }

    // Take field
    pub fn take_writingprogram(&mut self) -> ::std::string::String {
        self.writingprogram.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string source = 17;

    pub fn source(&self) -> &str {
        match self.source.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_source(&mut self) {
        self.source = ::std::option::Option::None;
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: ::std::string::String) {
        self.source = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut ::std::string::String {
        if self.source.is_none() {
            self.source = ::std::option::Option::Some(::std::string::String::new());
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> ::std::string::String {
        self.source.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 osmosis_replication_timestamp = 32;

    pub fn osmosis_replication_timestamp(&self) -> i64 {
        self.osmosis_replication_timestamp.unwrap_or(0)
    }

    pub fn clear_osmosis_replication_timestamp(&mut self) {
        self.osmosis_replication_timestamp = ::std::option::Option::None;
    }

    pub fn has_osmosis_replication_timestamp(&self) -> bool {
        self.osmosis_replication_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_osmosis_replication_timestamp(&mut self, v: i64) {
        self.osmosis_replication_timestamp = ::std::option::Option::Some(v);
    }

    // optional int64 osmosis_replication_sequence_number = 33;

    pub fn osmosis_replication_sequence_number(&self) -> i64 {
        self.osmosis_replication_sequence_number.unwrap_or(0)
    }

    pub fn clear_osmosis_replication_sequence_number(&mut self) {
        self.osmosis_replication_sequence_number = ::std::option::Option::None;
    }

    pub fn has_osmosis_replication_sequence_number(&self) -> bool {
        self.osmosis_replication_sequence_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_osmosis_replication_sequence_number(&mut self, v: i64) {
        self.osmosis_replication_sequence_number = ::std::option::Option::Some(v);
    }

    // optional string osmosis_replication_base_url = 34;

    pub fn osmosis_replication_base_url(&self) -> &str {
        match self.osmosis_replication_base_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_osmosis_replication_base_url(&mut self) {
        self.osmosis_replication_base_url = ::std::option::Option::None;
    }

    pub fn has_osmosis_replication_base_url(&self) -> bool {
        self.osmosis_replication_base_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_osmosis_replication_base_url(&mut self, v: ::std::string::String) {
        self.osmosis_replication_base_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_osmosis_replication_base_url(&mut self) -> &mut ::std::string::String {
        if self.osmosis_replication_base_url.is_none() {
            self.osmosis_replication_base_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.osmosis_replication_base_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_osmosis_replication_base_url(&mut self) -> ::std::string::String {
        self.osmosis_replication_base_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, HeaderBBox>(
            "bbox",
            |m: &HeaderBlock| { &m.bbox },
            |m: &mut HeaderBlock| { &mut m.bbox },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "required_features",
            |m: &HeaderBlock| { &m.required_features },
            |m: &mut HeaderBlock| { &mut m.required_features },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "optional_features",
            |m: &HeaderBlock| { &m.optional_features },
            |m: &mut HeaderBlock| { &mut m.optional_features },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "writingprogram",
            |m: &HeaderBlock| { &m.writingprogram },
            |m: &mut HeaderBlock| { &mut m.writingprogram },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source",
            |m: &HeaderBlock| { &m.source },
            |m: &mut HeaderBlock| { &mut m.source },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "osmosis_replication_timestamp",
            |m: &HeaderBlock| { &m.osmosis_replication_timestamp },
            |m: &mut HeaderBlock| { &mut m.osmosis_replication_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "osmosis_replication_sequence_number",
            |m: &HeaderBlock| { &m.osmosis_replication_sequence_number },
            |m: &mut HeaderBlock| { &mut m.osmosis_replication_sequence_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "osmosis_replication_base_url",
            |m: &HeaderBlock| { &m.osmosis_replication_base_url },
            |m: &mut HeaderBlock| { &mut m.osmosis_replication_base_url },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HeaderBlock>(
            "HeaderBlock",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HeaderBlock {
    const NAME: &'static str = "HeaderBlock";

    fn is_initialized(&self) -> bool {
        for v in &self.bbox {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bbox)?;
                },
                34 => {
                    self.required_features.push(is.read_string()?);
                },
                42 => {
                    self.optional_features.push(is.read_string()?);
                },
                130 => {
                    self.writingprogram = ::std::option::Option::Some(is.read_string()?);
                },
                138 => {
                    self.source = ::std::option::Option::Some(is.read_string()?);
                },
                256 => {
                    self.osmosis_replication_timestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                264 => {
                    self.osmosis_replication_sequence_number = ::std::option::Option::Some(is.read_int64()?);
                },
                274 => {
                    self.osmosis_replication_base_url = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.bbox.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.required_features {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.optional_features {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if let Some(v) = self.writingprogram.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        if let Some(v) = self.source.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        if let Some(v) = self.osmosis_replication_timestamp {
            my_size += ::protobuf::rt::int64_size(32, v);
        }
        if let Some(v) = self.osmosis_replication_sequence_number {
            my_size += ::protobuf::rt::int64_size(33, v);
        }
        if let Some(v) = self.osmosis_replication_base_url.as_ref() {
            my_size += ::protobuf::rt::string_size(34, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.bbox.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.required_features {
            os.write_string(4, &v)?;
        };
        for v in &self.optional_features {
            os.write_string(5, &v)?;
        };
        if let Some(v) = self.writingprogram.as_ref() {
            os.write_string(16, v)?;
        }
        if let Some(v) = self.source.as_ref() {
            os.write_string(17, v)?;
        }
        if let Some(v) = self.osmosis_replication_timestamp {
            os.write_int64(32, v)?;
        }
        if let Some(v) = self.osmosis_replication_sequence_number {
            os.write_int64(33, v)?;
        }
        if let Some(v) = self.osmosis_replication_base_url.as_ref() {
            os.write_string(34, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HeaderBlock {
        HeaderBlock::new()
    }

    fn clear(&mut self) {
        self.bbox.clear();
        self.required_features.clear();
        self.optional_features.clear();
        self.writingprogram = ::std::option::Option::None;
        self.source = ::std::option::Option::None;
        self.osmosis_replication_timestamp = ::std::option::Option::None;
        self.osmosis_replication_sequence_number = ::std::option::Option::None;
        self.osmosis_replication_base_url = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HeaderBlock {
        static instance: HeaderBlock = HeaderBlock {
            bbox: ::protobuf::MessageField::none(),
            required_features: ::std::vec::Vec::new(),
            optional_features: ::std::vec::Vec::new(),
            writingprogram: ::std::option::Option::None,
            source: ::std::option::Option::None,
            osmosis_replication_timestamp: ::std::option::Option::None,
            osmosis_replication_sequence_number: ::std::option::Option::None,
            osmosis_replication_base_url: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HeaderBlock {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HeaderBlock").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HeaderBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HeaderBlock {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:OSMPBF.HeaderBBox)
pub struct HeaderBBox {
    // message fields
    // @@protoc_insertion_point(field:OSMPBF.HeaderBBox.left)
    pub left: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:OSMPBF.HeaderBBox.right)
    pub right: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:OSMPBF.HeaderBBox.top)
    pub top: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:OSMPBF.HeaderBBox.bottom)
    pub bottom: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:OSMPBF.HeaderBBox.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HeaderBBox {
    fn default() -> &'a HeaderBBox {
        <HeaderBBox as ::protobuf::Message>::default_instance()
    }
}

impl HeaderBBox {
    pub fn new() -> HeaderBBox {
        ::std::default::Default::default()
    }

    // required sint64 left = 1;

    pub fn left(&self) -> i64 {
        self.left.unwrap_or(0)
    }

    pub fn clear_left(&mut self) {
        self.left = ::std::option::Option::None;
    }

    pub fn has_left(&self) -> bool {
        self.left.is_some()
    }

    // Param is passed by value, moved
    pub fn set_left(&mut self, v: i64) {
        self.left = ::std::option::Option::Some(v);
    }

    // required sint64 right = 2;

    pub fn right(&self) -> i64 {
        self.right.unwrap_or(0)
    }

    pub fn clear_right(&mut self) {
        self.right = ::std::option::Option::None;
    }

    pub fn has_right(&self) -> bool {
        self.right.is_some()
    }

    // Param is passed by value, moved
    pub fn set_right(&mut self, v: i64) {
        self.right = ::std::option::Option::Some(v);
    }

    // required sint64 top = 3;

    pub fn top(&self) -> i64 {
        self.top.unwrap_or(0)
    }

    pub fn clear_top(&mut self) {
        self.top = ::std::option::Option::None;
    }

    pub fn has_top(&self) -> bool {
        self.top.is_some()
    }

    // Param is passed by value, moved
    pub fn set_top(&mut self, v: i64) {
        self.top = ::std::option::Option::Some(v);
    }

    // required sint64 bottom = 4;

    pub fn bottom(&self) -> i64 {
        self.bottom.unwrap_or(0)
    }

    pub fn clear_bottom(&mut self) {
        self.bottom = ::std::option::Option::None;
    }

    pub fn has_bottom(&self) -> bool {
        self.bottom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bottom(&mut self, v: i64) {
        self.bottom = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "left",
            |m: &HeaderBBox| { &m.left },
            |m: &mut HeaderBBox| { &mut m.left },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "right",
            |m: &HeaderBBox| { &m.right },
            |m: &mut HeaderBBox| { &mut m.right },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "top",
            |m: &HeaderBBox| { &m.top },
            |m: &mut HeaderBBox| { &mut m.top },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bottom",
            |m: &HeaderBBox| { &m.bottom },
            |m: &mut HeaderBBox| { &mut m.bottom },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HeaderBBox>(
            "HeaderBBox",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HeaderBBox {
    const NAME: &'static str = "HeaderBBox";

    fn is_initialized(&self) -> bool {
        if self.left.is_none() {
            return false;
        }
        if self.right.is_none() {
            return false;
        }
        if self.top.is_none() {
            return false;
        }
        if self.bottom.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.left = ::std::option::Option::Some(is.read_sint64()?);
                },
                16 => {
                    self.right = ::std::option::Option::Some(is.read_sint64()?);
                },
                24 => {
                    self.top = ::std::option::Option::Some(is.read_sint64()?);
                },
                32 => {
                    self.bottom = ::std::option::Option::Some(is.read_sint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.left {
            my_size += ::protobuf::rt::sint64_size(1, v);
        }
        if let Some(v) = self.right {
            my_size += ::protobuf::rt::sint64_size(2, v);
        }
        if let Some(v) = self.top {
            my_size += ::protobuf::rt::sint64_size(3, v);
        }
        if let Some(v) = self.bottom {
            my_size += ::protobuf::rt::sint64_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.left {
            os.write_sint64(1, v)?;
        }
        if let Some(v) = self.right {
            os.write_sint64(2, v)?;
        }
        if let Some(v) = self.top {
            os.write_sint64(3, v)?;
        }
        if let Some(v) = self.bottom {
            os.write_sint64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HeaderBBox {
        HeaderBBox::new()
    }

    fn clear(&mut self) {
        self.left = ::std::option::Option::None;
        self.right = ::std::option::Option::None;
        self.top = ::std::option::Option::None;
        self.bottom = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HeaderBBox {
        static instance: HeaderBBox = HeaderBBox {
            left: ::std::option::Option::None,
            right: ::std::option::Option::None,
            top: ::std::option::Option::None,
            bottom: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HeaderBBox {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HeaderBBox").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HeaderBBox {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HeaderBBox {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:OSMPBF.PrimitiveBlock)
pub struct PrimitiveBlock {
    // message fields
    // @@protoc_insertion_point(field:OSMPBF.PrimitiveBlock.stringtable)
    pub stringtable: ::protobuf::MessageField<StringTable>,
    // @@protoc_insertion_point(field:OSMPBF.PrimitiveBlock.primitivegroup)
    pub primitivegroup: ::std::vec::Vec<PrimitiveGroup>,
    // @@protoc_insertion_point(field:OSMPBF.PrimitiveBlock.granularity)
    pub granularity: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:OSMPBF.PrimitiveBlock.lat_offset)
    pub lat_offset: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:OSMPBF.PrimitiveBlock.lon_offset)
    pub lon_offset: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:OSMPBF.PrimitiveBlock.date_granularity)
    pub date_granularity: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:OSMPBF.PrimitiveBlock.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PrimitiveBlock {
    fn default() -> &'a PrimitiveBlock {
        <PrimitiveBlock as ::protobuf::Message>::default_instance()
    }
}

impl PrimitiveBlock {
    pub fn new() -> PrimitiveBlock {
        ::std::default::Default::default()
    }

    // optional int32 granularity = 17;

    pub fn granularity(&self) -> i32 {
        self.granularity.unwrap_or(100i32)
    }

    pub fn clear_granularity(&mut self) {
        self.granularity = ::std::option::Option::None;
    }

    pub fn has_granularity(&self) -> bool {
        self.granularity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_granularity(&mut self, v: i32) {
        self.granularity = ::std::option::Option::Some(v);
    }

    // optional int64 lat_offset = 19;

    pub fn lat_offset(&self) -> i64 {
        self.lat_offset.unwrap_or(0i64)
    }

    pub fn clear_lat_offset(&mut self) {
        self.lat_offset = ::std::option::Option::None;
    }

    pub fn has_lat_offset(&self) -> bool {
        self.lat_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lat_offset(&mut self, v: i64) {
        self.lat_offset = ::std::option::Option::Some(v);
    }

    // optional int64 lon_offset = 20;

    pub fn lon_offset(&self) -> i64 {
        self.lon_offset.unwrap_or(0i64)
    }

    pub fn clear_lon_offset(&mut self) {
        self.lon_offset = ::std::option::Option::None;
    }

    pub fn has_lon_offset(&self) -> bool {
        self.lon_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lon_offset(&mut self, v: i64) {
        self.lon_offset = ::std::option::Option::Some(v);
    }

    // optional int32 date_granularity = 18;

    pub fn date_granularity(&self) -> i32 {
        self.date_granularity.unwrap_or(1000i32)
    }

    pub fn clear_date_granularity(&mut self) {
        self.date_granularity = ::std::option::Option::None;
    }

    pub fn has_date_granularity(&self) -> bool {
        self.date_granularity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_date_granularity(&mut self, v: i32) {
        self.date_granularity = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StringTable>(
            "stringtable",
            |m: &PrimitiveBlock| { &m.stringtable },
            |m: &mut PrimitiveBlock| { &mut m.stringtable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "primitivegroup",
            |m: &PrimitiveBlock| { &m.primitivegroup },
            |m: &mut PrimitiveBlock| { &mut m.primitivegroup },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "granularity",
            |m: &PrimitiveBlock| { &m.granularity },
            |m: &mut PrimitiveBlock| { &mut m.granularity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lat_offset",
            |m: &PrimitiveBlock| { &m.lat_offset },
            |m: &mut PrimitiveBlock| { &mut m.lat_offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lon_offset",
            |m: &PrimitiveBlock| { &m.lon_offset },
            |m: &mut PrimitiveBlock| { &mut m.lon_offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "date_granularity",
            |m: &PrimitiveBlock| { &m.date_granularity },
            |m: &mut PrimitiveBlock| { &mut m.date_granularity },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PrimitiveBlock>(
            "PrimitiveBlock",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PrimitiveBlock {
    const NAME: &'static str = "PrimitiveBlock";

    fn is_initialized(&self) -> bool {
        if self.stringtable.is_none() {
            return false;
        }
        for v in &self.stringtable {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.primitivegroup {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.stringtable)?;
                },
                18 => {
                    self.primitivegroup.push(is.read_message()?);
                },
                136 => {
                    self.granularity = ::std::option::Option::Some(is.read_int32()?);
                },
                152 => {
                    self.lat_offset = ::std::option::Option::Some(is.read_int64()?);
                },
                160 => {
                    self.lon_offset = ::std::option::Option::Some(is.read_int64()?);
                },
                144 => {
                    self.date_granularity = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stringtable.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.primitivegroup {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.granularity {
            my_size += ::protobuf::rt::int32_size(17, v);
        }
        if let Some(v) = self.lat_offset {
            my_size += ::protobuf::rt::int64_size(19, v);
        }
        if let Some(v) = self.lon_offset {
            my_size += ::protobuf::rt::int64_size(20, v);
        }
        if let Some(v) = self.date_granularity {
            my_size += ::protobuf::rt::int32_size(18, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.stringtable.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.primitivegroup {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.granularity {
            os.write_int32(17, v)?;
        }
        if let Some(v) = self.lat_offset {
            os.write_int64(19, v)?;
        }
        if let Some(v) = self.lon_offset {
            os.write_int64(20, v)?;
        }
        if let Some(v) = self.date_granularity {
            os.write_int32(18, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PrimitiveBlock {
        PrimitiveBlock::new()
    }

    fn clear(&mut self) {
        self.stringtable.clear();
        self.primitivegroup.clear();
        self.granularity = ::std::option::Option::None;
        self.lat_offset = ::std::option::Option::None;
        self.lon_offset = ::std::option::Option::None;
        self.date_granularity = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PrimitiveBlock {
        static instance: PrimitiveBlock = PrimitiveBlock {
            stringtable: ::protobuf::MessageField::none(),
            primitivegroup: ::std::vec::Vec::new(),
            granularity: ::std::option::Option::None,
            lat_offset: ::std::option::Option::None,
            lon_offset: ::std::option::Option::None,
            date_granularity: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PrimitiveBlock {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PrimitiveBlock").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PrimitiveBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PrimitiveBlock {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:OSMPBF.PrimitiveGroup)
pub struct PrimitiveGroup {
    // message fields
    // @@protoc_insertion_point(field:OSMPBF.PrimitiveGroup.nodes)
    pub nodes: ::std::vec::Vec<Node>,
    // @@protoc_insertion_point(field:OSMPBF.PrimitiveGroup.dense)
    pub dense: ::protobuf::MessageField<DenseNodes>,
    // @@protoc_insertion_point(field:OSMPBF.PrimitiveGroup.ways)
    pub ways: ::std::vec::Vec<Way>,
    // @@protoc_insertion_point(field:OSMPBF.PrimitiveGroup.relations)
    pub relations: ::std::vec::Vec<Relation>,
    // @@protoc_insertion_point(field:OSMPBF.PrimitiveGroup.changesets)
    pub changesets: ::std::vec::Vec<ChangeSet>,
    // special fields
    // @@protoc_insertion_point(special_field:OSMPBF.PrimitiveGroup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PrimitiveGroup {
    fn default() -> &'a PrimitiveGroup {
        <PrimitiveGroup as ::protobuf::Message>::default_instance()
    }
}

impl PrimitiveGroup {
    pub fn new() -> PrimitiveGroup {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "nodes",
            |m: &PrimitiveGroup| { &m.nodes },
            |m: &mut PrimitiveGroup| { &mut m.nodes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DenseNodes>(
            "dense",
            |m: &PrimitiveGroup| { &m.dense },
            |m: &mut PrimitiveGroup| { &mut m.dense },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ways",
            |m: &PrimitiveGroup| { &m.ways },
            |m: &mut PrimitiveGroup| { &mut m.ways },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "relations",
            |m: &PrimitiveGroup| { &m.relations },
            |m: &mut PrimitiveGroup| { &mut m.relations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "changesets",
            |m: &PrimitiveGroup| { &m.changesets },
            |m: &mut PrimitiveGroup| { &mut m.changesets },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PrimitiveGroup>(
            "PrimitiveGroup",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PrimitiveGroup {
    const NAME: &'static str = "PrimitiveGroup";

    fn is_initialized(&self) -> bool {
        for v in &self.nodes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dense {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ways {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.relations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.changesets {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.nodes.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dense)?;
                },
                26 => {
                    self.ways.push(is.read_message()?);
                },
                34 => {
                    self.relations.push(is.read_message()?);
                },
                42 => {
                    self.changesets.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.nodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.dense.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ways {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.relations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.changesets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.nodes {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.dense.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.ways {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.relations {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.changesets {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PrimitiveGroup {
        PrimitiveGroup::new()
    }

    fn clear(&mut self) {
        self.nodes.clear();
        self.dense.clear();
        self.ways.clear();
        self.relations.clear();
        self.changesets.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PrimitiveGroup {
        static instance: PrimitiveGroup = PrimitiveGroup {
            nodes: ::std::vec::Vec::new(),
            dense: ::protobuf::MessageField::none(),
            ways: ::std::vec::Vec::new(),
            relations: ::std::vec::Vec::new(),
            changesets: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PrimitiveGroup {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PrimitiveGroup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PrimitiveGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PrimitiveGroup {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:OSMPBF.StringTable)
pub struct StringTable {
    // message fields
    // @@protoc_insertion_point(field:OSMPBF.StringTable.s)
    pub s: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:OSMPBF.StringTable.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StringTable {
    fn default() -> &'a StringTable {
        <StringTable as ::protobuf::Message>::default_instance()
    }
}

impl StringTable {
    pub fn new() -> StringTable {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "s",
            |m: &StringTable| { &m.s },
            |m: &mut StringTable| { &mut m.s },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StringTable>(
            "StringTable",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StringTable {
    const NAME: &'static str = "StringTable";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.s.push(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.s {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.s {
            os.write_bytes(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StringTable {
        StringTable::new()
    }

    fn clear(&mut self) {
        self.s.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StringTable {
        static instance: StringTable = StringTable {
            s: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StringTable {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StringTable").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StringTable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StringTable {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:OSMPBF.Info)
pub struct Info {
    // message fields
    // @@protoc_insertion_point(field:OSMPBF.Info.version)
    pub version: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:OSMPBF.Info.timestamp)
    pub timestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:OSMPBF.Info.changeset)
    pub changeset: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:OSMPBF.Info.uid)
    pub uid: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:OSMPBF.Info.user_sid)
    pub user_sid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:OSMPBF.Info.visible)
    pub visible: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:OSMPBF.Info.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Info {
    fn default() -> &'a Info {
        <Info as ::protobuf::Message>::default_instance()
    }
}

impl Info {
    pub fn new() -> Info {
        ::std::default::Default::default()
    }

    // optional int32 version = 1;

    pub fn version(&self) -> i32 {
        self.version.unwrap_or(-1i32)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional int64 timestamp = 2;

    pub fn timestamp(&self) -> i64 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional int64 changeset = 3;

    pub fn changeset(&self) -> i64 {
        self.changeset.unwrap_or(0)
    }

    pub fn clear_changeset(&mut self) {
        self.changeset = ::std::option::Option::None;
    }

    pub fn has_changeset(&self) -> bool {
        self.changeset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_changeset(&mut self, v: i64) {
        self.changeset = ::std::option::Option::Some(v);
    }

    // optional int32 uid = 4;

    pub fn uid(&self) -> i32 {
        self.uid.unwrap_or(0)
    }

    pub fn clear_uid(&mut self) {
        self.uid = ::std::option::Option::None;
    }

    pub fn has_uid(&self) -> bool {
        self.uid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: i32) {
        self.uid = ::std::option::Option::Some(v);
    }

    // optional uint32 user_sid = 5;

    pub fn user_sid(&self) -> u32 {
        self.user_sid.unwrap_or(0)
    }

    pub fn clear_user_sid(&mut self) {
        self.user_sid = ::std::option::Option::None;
    }

    pub fn has_user_sid(&self) -> bool {
        self.user_sid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_sid(&mut self, v: u32) {
        self.user_sid = ::std::option::Option::Some(v);
    }

    // optional bool visible = 6;

    pub fn visible(&self) -> bool {
        self.visible.unwrap_or(false)
    }

    pub fn clear_visible(&mut self) {
        self.visible = ::std::option::Option::None;
    }

    pub fn has_visible(&self) -> bool {
        self.visible.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visible(&mut self, v: bool) {
        self.visible = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &Info| { &m.version },
            |m: &mut Info| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &Info| { &m.timestamp },
            |m: &mut Info| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "changeset",
            |m: &Info| { &m.changeset },
            |m: &mut Info| { &mut m.changeset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uid",
            |m: &Info| { &m.uid },
            |m: &mut Info| { &mut m.uid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "user_sid",
            |m: &Info| { &m.user_sid },
            |m: &mut Info| { &mut m.user_sid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "visible",
            |m: &Info| { &m.visible },
            |m: &mut Info| { &mut m.visible },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Info>(
            "Info",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Info {
    const NAME: &'static str = "Info";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.timestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.changeset = ::std::option::Option::Some(is.read_int64()?);
                },
                32 => {
                    self.uid = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.user_sid = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.visible = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.changeset {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        if let Some(v) = self.uid {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.user_sid {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.visible {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.changeset {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.uid {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.user_sid {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.visible {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Info {
        Info::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.changeset = ::std::option::Option::None;
        self.uid = ::std::option::Option::None;
        self.user_sid = ::std::option::Option::None;
        self.visible = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Info {
        static instance: Info = Info {
            version: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            changeset: ::std::option::Option::None,
            uid: ::std::option::Option::None,
            user_sid: ::std::option::Option::None,
            visible: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Info {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Info").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Info {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Info {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:OSMPBF.DenseInfo)
pub struct DenseInfo {
    // message fields
    // @@protoc_insertion_point(field:OSMPBF.DenseInfo.version)
    pub version: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:OSMPBF.DenseInfo.timestamp)
    pub timestamp: ::std::vec::Vec<i64>,
    // @@protoc_insertion_point(field:OSMPBF.DenseInfo.changeset)
    pub changeset: ::std::vec::Vec<i64>,
    // @@protoc_insertion_point(field:OSMPBF.DenseInfo.uid)
    pub uid: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:OSMPBF.DenseInfo.user_sid)
    pub user_sid: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:OSMPBF.DenseInfo.visible)
    pub visible: ::std::vec::Vec<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:OSMPBF.DenseInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DenseInfo {
    fn default() -> &'a DenseInfo {
        <DenseInfo as ::protobuf::Message>::default_instance()
    }
}

impl DenseInfo {
    pub fn new() -> DenseInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "version",
            |m: &DenseInfo| { &m.version },
            |m: &mut DenseInfo| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "timestamp",
            |m: &DenseInfo| { &m.timestamp },
            |m: &mut DenseInfo| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "changeset",
            |m: &DenseInfo| { &m.changeset },
            |m: &mut DenseInfo| { &mut m.changeset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uid",
            |m: &DenseInfo| { &m.uid },
            |m: &mut DenseInfo| { &mut m.uid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "user_sid",
            |m: &DenseInfo| { &m.user_sid },
            |m: &mut DenseInfo| { &mut m.user_sid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "visible",
            |m: &DenseInfo| { &m.visible },
            |m: &mut DenseInfo| { &mut m.visible },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DenseInfo>(
            "DenseInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DenseInfo {
    const NAME: &'static str = "DenseInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_int32_into(&mut self.version)?;
                },
                8 => {
                    self.version.push(is.read_int32()?);
                },
                18 => {
                    is.read_repeated_packed_sint64_into(&mut self.timestamp)?;
                },
                16 => {
                    self.timestamp.push(is.read_sint64()?);
                },
                26 => {
                    is.read_repeated_packed_sint64_into(&mut self.changeset)?;
                },
                24 => {
                    self.changeset.push(is.read_sint64()?);
                },
                34 => {
                    is.read_repeated_packed_sint32_into(&mut self.uid)?;
                },
                32 => {
                    self.uid.push(is.read_sint32()?);
                },
                42 => {
                    is.read_repeated_packed_sint32_into(&mut self.user_sid)?;
                },
                40 => {
                    self.user_sid.push(is.read_sint32()?);
                },
                50 => {
                    is.read_repeated_packed_bool_into(&mut self.visible)?;
                },
                48 => {
                    self.visible.push(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::vec_packed_int32_size(1, &self.version);
        my_size += ::protobuf::rt::vec_packed_sint64_size(2, &self.timestamp);
        my_size += ::protobuf::rt::vec_packed_sint64_size(3, &self.changeset);
        my_size += ::protobuf::rt::vec_packed_sint32_size(4, &self.uid);
        my_size += ::protobuf::rt::vec_packed_sint32_size(5, &self.user_sid);
        my_size += ::protobuf::rt::vec_packed_bool_size(6, &self.visible);
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_repeated_packed_int32(1, &self.version)?;
        os.write_repeated_packed_sint64(2, &self.timestamp)?;
        os.write_repeated_packed_sint64(3, &self.changeset)?;
        os.write_repeated_packed_sint32(4, &self.uid)?;
        os.write_repeated_packed_sint32(5, &self.user_sid)?;
        os.write_repeated_packed_bool(6, &self.visible)?;
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DenseInfo {
        DenseInfo::new()
    }

    fn clear(&mut self) {
        self.version.clear();
        self.timestamp.clear();
        self.changeset.clear();
        self.uid.clear();
        self.user_sid.clear();
        self.visible.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DenseInfo {
        static instance: DenseInfo = DenseInfo {
            version: ::std::vec::Vec::new(),
            timestamp: ::std::vec::Vec::new(),
            changeset: ::std::vec::Vec::new(),
            uid: ::std::vec::Vec::new(),
            user_sid: ::std::vec::Vec::new(),
            visible: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DenseInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DenseInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DenseInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DenseInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:OSMPBF.ChangeSet)
pub struct ChangeSet {
    // message fields
    // @@protoc_insertion_point(field:OSMPBF.ChangeSet.id)
    pub id: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:OSMPBF.ChangeSet.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChangeSet {
    fn default() -> &'a ChangeSet {
        <ChangeSet as ::protobuf::Message>::default_instance()
    }
}

impl ChangeSet {
    pub fn new() -> ChangeSet {
        ::std::default::Default::default()
    }

    // required int64 id = 1;

    pub fn id(&self) -> i64 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &ChangeSet| { &m.id },
            |m: &mut ChangeSet| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChangeSet>(
            "ChangeSet",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ChangeSet {
    const NAME: &'static str = "ChangeSet";

    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChangeSet {
        ChangeSet::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChangeSet {
        static instance: ChangeSet = ChangeSet {
            id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ChangeSet {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ChangeSet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ChangeSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChangeSet {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:OSMPBF.Node)
pub struct Node {
    // message fields
    // @@protoc_insertion_point(field:OSMPBF.Node.id)
    pub id: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:OSMPBF.Node.keys)
    pub keys: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:OSMPBF.Node.vals)
    pub vals: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:OSMPBF.Node.info)
    pub info: ::protobuf::MessageField<Info>,
    // @@protoc_insertion_point(field:OSMPBF.Node.lat)
    pub lat: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:OSMPBF.Node.lon)
    pub lon: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:OSMPBF.Node.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Node {
    fn default() -> &'a Node {
        <Node as ::protobuf::Message>::default_instance()
    }
}

impl Node {
    pub fn new() -> Node {
        ::std::default::Default::default()
    }

    // required sint64 id = 1;

    pub fn id(&self) -> i64 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = ::std::option::Option::Some(v);
    }

    // required sint64 lat = 8;

    pub fn lat(&self) -> i64 {
        self.lat.unwrap_or(0)
    }

    pub fn clear_lat(&mut self) {
        self.lat = ::std::option::Option::None;
    }

    pub fn has_lat(&self) -> bool {
        self.lat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lat(&mut self, v: i64) {
        self.lat = ::std::option::Option::Some(v);
    }

    // required sint64 lon = 9;

    pub fn lon(&self) -> i64 {
        self.lon.unwrap_or(0)
    }

    pub fn clear_lon(&mut self) {
        self.lon = ::std::option::Option::None;
    }

    pub fn has_lon(&self) -> bool {
        self.lon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lon(&mut self, v: i64) {
        self.lon = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &Node| { &m.id },
            |m: &mut Node| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "keys",
            |m: &Node| { &m.keys },
            |m: &mut Node| { &mut m.keys },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "vals",
            |m: &Node| { &m.vals },
            |m: &mut Node| { &mut m.vals },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Info>(
            "info",
            |m: &Node| { &m.info },
            |m: &mut Node| { &mut m.info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lat",
            |m: &Node| { &m.lat },
            |m: &mut Node| { &mut m.lat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lon",
            |m: &Node| { &m.lon },
            |m: &mut Node| { &mut m.lon },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Node>(
            "Node",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Node {
    const NAME: &'static str = "Node";

    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        if self.lat.is_none() {
            return false;
        }
        if self.lon.is_none() {
            return false;
        }
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_sint64()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.keys)?;
                },
                16 => {
                    self.keys.push(is.read_uint32()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.vals)?;
                },
                24 => {
                    self.vals.push(is.read_uint32()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.info)?;
                },
                64 => {
                    self.lat = ::std::option::Option::Some(is.read_sint64()?);
                },
                72 => {
                    self.lon = ::std::option::Option::Some(is.read_sint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::sint64_size(1, v);
        }
        my_size += ::protobuf::rt::vec_packed_uint32_size(2, &self.keys);
        my_size += ::protobuf::rt::vec_packed_uint32_size(3, &self.vals);
        if let Some(v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.lat {
            my_size += ::protobuf::rt::sint64_size(8, v);
        }
        if let Some(v) = self.lon {
            my_size += ::protobuf::rt::sint64_size(9, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_sint64(1, v)?;
        }
        os.write_repeated_packed_uint32(2, &self.keys)?;
        os.write_repeated_packed_uint32(3, &self.vals)?;
        if let Some(v) = self.info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.lat {
            os.write_sint64(8, v)?;
        }
        if let Some(v) = self.lon {
            os.write_sint64(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Node {
        Node::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.keys.clear();
        self.vals.clear();
        self.info.clear();
        self.lat = ::std::option::Option::None;
        self.lon = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Node {
        static instance: Node = Node {
            id: ::std::option::Option::None,
            keys: ::std::vec::Vec::new(),
            vals: ::std::vec::Vec::new(),
            info: ::protobuf::MessageField::none(),
            lat: ::std::option::Option::None,
            lon: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Node {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Node").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Node {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Node {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:OSMPBF.DenseNodes)
pub struct DenseNodes {
    // message fields
    // @@protoc_insertion_point(field:OSMPBF.DenseNodes.id)
    pub id: ::std::vec::Vec<i64>,
    // @@protoc_insertion_point(field:OSMPBF.DenseNodes.denseinfo)
    pub denseinfo: ::protobuf::MessageField<DenseInfo>,
    // @@protoc_insertion_point(field:OSMPBF.DenseNodes.lat)
    pub lat: ::std::vec::Vec<i64>,
    // @@protoc_insertion_point(field:OSMPBF.DenseNodes.lon)
    pub lon: ::std::vec::Vec<i64>,
    // @@protoc_insertion_point(field:OSMPBF.DenseNodes.keys_vals)
    pub keys_vals: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:OSMPBF.DenseNodes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DenseNodes {
    fn default() -> &'a DenseNodes {
        <DenseNodes as ::protobuf::Message>::default_instance()
    }
}

impl DenseNodes {
    pub fn new() -> DenseNodes {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "id",
            |m: &DenseNodes| { &m.id },
            |m: &mut DenseNodes| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DenseInfo>(
            "denseinfo",
            |m: &DenseNodes| { &m.denseinfo },
            |m: &mut DenseNodes| { &mut m.denseinfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "lat",
            |m: &DenseNodes| { &m.lat },
            |m: &mut DenseNodes| { &mut m.lat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "lon",
            |m: &DenseNodes| { &m.lon },
            |m: &mut DenseNodes| { &mut m.lon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "keys_vals",
            |m: &DenseNodes| { &m.keys_vals },
            |m: &mut DenseNodes| { &mut m.keys_vals },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DenseNodes>(
            "DenseNodes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DenseNodes {
    const NAME: &'static str = "DenseNodes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_sint64_into(&mut self.id)?;
                },
                8 => {
                    self.id.push(is.read_sint64()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.denseinfo)?;
                },
                66 => {
                    is.read_repeated_packed_sint64_into(&mut self.lat)?;
                },
                64 => {
                    self.lat.push(is.read_sint64()?);
                },
                74 => {
                    is.read_repeated_packed_sint64_into(&mut self.lon)?;
                },
                72 => {
                    self.lon.push(is.read_sint64()?);
                },
                82 => {
                    is.read_repeated_packed_int32_into(&mut self.keys_vals)?;
                },
                80 => {
                    self.keys_vals.push(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::vec_packed_sint64_size(1, &self.id);
        if let Some(v) = self.denseinfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::vec_packed_sint64_size(8, &self.lat);
        my_size += ::protobuf::rt::vec_packed_sint64_size(9, &self.lon);
        my_size += ::protobuf::rt::vec_packed_int32_size(10, &self.keys_vals);
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_repeated_packed_sint64(1, &self.id)?;
        if let Some(v) = self.denseinfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_repeated_packed_sint64(8, &self.lat)?;
        os.write_repeated_packed_sint64(9, &self.lon)?;
        os.write_repeated_packed_int32(10, &self.keys_vals)?;
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DenseNodes {
        DenseNodes::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.denseinfo.clear();
        self.lat.clear();
        self.lon.clear();
        self.keys_vals.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DenseNodes {
        static instance: DenseNodes = DenseNodes {
            id: ::std::vec::Vec::new(),
            denseinfo: ::protobuf::MessageField::none(),
            lat: ::std::vec::Vec::new(),
            lon: ::std::vec::Vec::new(),
            keys_vals: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DenseNodes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DenseNodes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DenseNodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DenseNodes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:OSMPBF.Way)
pub struct Way {
    // message fields
    // @@protoc_insertion_point(field:OSMPBF.Way.id)
    pub id: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:OSMPBF.Way.keys)
    pub keys: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:OSMPBF.Way.vals)
    pub vals: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:OSMPBF.Way.info)
    pub info: ::protobuf::MessageField<Info>,
    // @@protoc_insertion_point(field:OSMPBF.Way.refs)
    pub refs: ::std::vec::Vec<i64>,
    // @@protoc_insertion_point(field:OSMPBF.Way.lat)
    pub lat: ::std::vec::Vec<i64>,
    // @@protoc_insertion_point(field:OSMPBF.Way.lon)
    pub lon: ::std::vec::Vec<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:OSMPBF.Way.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Way {
    fn default() -> &'a Way {
        <Way as ::protobuf::Message>::default_instance()
    }
}

impl Way {
    pub fn new() -> Way {
        ::std::default::Default::default()
    }

    // required int64 id = 1;

    pub fn id(&self) -> i64 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &Way| { &m.id },
            |m: &mut Way| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "keys",
            |m: &Way| { &m.keys },
            |m: &mut Way| { &mut m.keys },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "vals",
            |m: &Way| { &m.vals },
            |m: &mut Way| { &mut m.vals },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Info>(
            "info",
            |m: &Way| { &m.info },
            |m: &mut Way| { &mut m.info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "refs",
            |m: &Way| { &m.refs },
            |m: &mut Way| { &mut m.refs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "lat",
            |m: &Way| { &m.lat },
            |m: &mut Way| { &mut m.lat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "lon",
            |m: &Way| { &m.lon },
            |m: &mut Way| { &mut m.lon },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Way>(
            "Way",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Way {
    const NAME: &'static str = "Way";

    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_int64()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.keys)?;
                },
                16 => {
                    self.keys.push(is.read_uint32()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.vals)?;
                },
                24 => {
                    self.vals.push(is.read_uint32()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.info)?;
                },
                66 => {
                    is.read_repeated_packed_sint64_into(&mut self.refs)?;
                },
                64 => {
                    self.refs.push(is.read_sint64()?);
                },
                74 => {
                    is.read_repeated_packed_sint64_into(&mut self.lat)?;
                },
                72 => {
                    self.lat.push(is.read_sint64()?);
                },
                82 => {
                    is.read_repeated_packed_sint64_into(&mut self.lon)?;
                },
                80 => {
                    self.lon.push(is.read_sint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        my_size += ::protobuf::rt::vec_packed_uint32_size(2, &self.keys);
        my_size += ::protobuf::rt::vec_packed_uint32_size(3, &self.vals);
        if let Some(v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::vec_packed_sint64_size(8, &self.refs);
        my_size += ::protobuf::rt::vec_packed_sint64_size(9, &self.lat);
        my_size += ::protobuf::rt::vec_packed_sint64_size(10, &self.lon);
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_int64(1, v)?;
        }
        os.write_repeated_packed_uint32(2, &self.keys)?;
        os.write_repeated_packed_uint32(3, &self.vals)?;
        if let Some(v) = self.info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_repeated_packed_sint64(8, &self.refs)?;
        os.write_repeated_packed_sint64(9, &self.lat)?;
        os.write_repeated_packed_sint64(10, &self.lon)?;
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Way {
        Way::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.keys.clear();
        self.vals.clear();
        self.info.clear();
        self.refs.clear();
        self.lat.clear();
        self.lon.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Way {
        static instance: Way = Way {
            id: ::std::option::Option::None,
            keys: ::std::vec::Vec::new(),
            vals: ::std::vec::Vec::new(),
            info: ::protobuf::MessageField::none(),
            refs: ::std::vec::Vec::new(),
            lat: ::std::vec::Vec::new(),
            lon: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Way {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Way").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Way {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Way {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:OSMPBF.Relation)
pub struct Relation {
    // message fields
    // @@protoc_insertion_point(field:OSMPBF.Relation.id)
    pub id: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:OSMPBF.Relation.keys)
    pub keys: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:OSMPBF.Relation.vals)
    pub vals: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:OSMPBF.Relation.info)
    pub info: ::protobuf::MessageField<Info>,
    // @@protoc_insertion_point(field:OSMPBF.Relation.roles_sid)
    pub roles_sid: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:OSMPBF.Relation.memids)
    pub memids: ::std::vec::Vec<i64>,
    // @@protoc_insertion_point(field:OSMPBF.Relation.types)
    pub types: ::std::vec::Vec<::protobuf::EnumOrUnknown<relation::MemberType>>,
    // special fields
    // @@protoc_insertion_point(special_field:OSMPBF.Relation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Relation {
    fn default() -> &'a Relation {
        <Relation as ::protobuf::Message>::default_instance()
    }
}

impl Relation {
    pub fn new() -> Relation {
        ::std::default::Default::default()
    }

    // required int64 id = 1;

    pub fn id(&self) -> i64 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &Relation| { &m.id },
            |m: &mut Relation| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "keys",
            |m: &Relation| { &m.keys },
            |m: &mut Relation| { &mut m.keys },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "vals",
            |m: &Relation| { &m.vals },
            |m: &mut Relation| { &mut m.vals },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Info>(
            "info",
            |m: &Relation| { &m.info },
            |m: &mut Relation| { &mut m.info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "roles_sid",
            |m: &Relation| { &m.roles_sid },
            |m: &mut Relation| { &mut m.roles_sid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "memids",
            |m: &Relation| { &m.memids },
            |m: &mut Relation| { &mut m.memids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "types",
            |m: &Relation| { &m.types },
            |m: &mut Relation| { &mut m.types },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Relation>(
            "Relation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Relation {
    const NAME: &'static str = "Relation";

    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_int64()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.keys)?;
                },
                16 => {
                    self.keys.push(is.read_uint32()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.vals)?;
                },
                24 => {
                    self.vals.push(is.read_uint32()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.info)?;
                },
                66 => {
                    is.read_repeated_packed_int32_into(&mut self.roles_sid)?;
                },
                64 => {
                    self.roles_sid.push(is.read_int32()?);
                },
                74 => {
                    is.read_repeated_packed_sint64_into(&mut self.memids)?;
                },
                72 => {
                    self.memids.push(is.read_sint64()?);
                },
                80 => {
                    self.types.push(is.read_enum_or_unknown()?);
                },
                82 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.types)?
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        my_size += ::protobuf::rt::vec_packed_uint32_size(2, &self.keys);
        my_size += ::protobuf::rt::vec_packed_uint32_size(3, &self.vals);
        if let Some(v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::vec_packed_int32_size(8, &self.roles_sid);
        my_size += ::protobuf::rt::vec_packed_sint64_size(9, &self.memids);
        my_size += ::protobuf::rt::vec_packed_enum_or_unknown_size(10, &self.types);
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_int64(1, v)?;
        }
        os.write_repeated_packed_uint32(2, &self.keys)?;
        os.write_repeated_packed_uint32(3, &self.vals)?;
        if let Some(v) = self.info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_repeated_packed_int32(8, &self.roles_sid)?;
        os.write_repeated_packed_sint64(9, &self.memids)?;
        os.write_repeated_packed_enum_or_unknown(10, &self.types)?;
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Relation {
        Relation::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.keys.clear();
        self.vals.clear();
        self.info.clear();
        self.roles_sid.clear();
        self.memids.clear();
        self.types.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Relation {
        static instance: Relation = Relation {
            id: ::std::option::Option::None,
            keys: ::std::vec::Vec::new(),
            vals: ::std::vec::Vec::new(),
            info: ::protobuf::MessageField::none(),
            roles_sid: ::std::vec::Vec::new(),
            memids: ::std::vec::Vec::new(),
            types: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Relation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Relation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Relation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Relation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Relation`
pub mod relation {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:OSMPBF.Relation.MemberType)
    pub enum MemberType {
        // @@protoc_insertion_point(enum_value:OSMPBF.Relation.MemberType.Node)
        Node = 0,
        // @@protoc_insertion_point(enum_value:OSMPBF.Relation.MemberType.Way)
        Way = 1,
        // @@protoc_insertion_point(enum_value:OSMPBF.Relation.MemberType.Relation)
        Relation = 2,
    }

    impl ::protobuf::Enum for MemberType {
        const NAME: &'static str = "MemberType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<MemberType> {
            match value {
                0 => ::std::option::Option::Some(MemberType::Node),
                1 => ::std::option::Option::Some(MemberType::Way),
                2 => ::std::option::Option::Some(MemberType::Relation),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [MemberType] = &[
            MemberType::Node,
            MemberType::Way,
            MemberType::Relation,
        ];
    }

    impl ::protobuf::EnumFull for MemberType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Relation.MemberType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for MemberType {
        fn default() -> Self {
            MemberType::Node
        }
    }

    impl MemberType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MemberType>("Relation.MemberType")
        }
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0fosmformat.proto\x12\x06OSMPBF\"\xa3\x03\n\x0bHeaderBlock\x12&\n\
    \x04bbox\x18\x01\x20\x01(\x0b2\x12.OSMPBF.HeaderBBoxR\x04bbox\x12+\n\x11\
    required_features\x18\x04\x20\x03(\tR\x10requiredFeatures\x12+\n\x11opti\
    onal_features\x18\x05\x20\x03(\tR\x10optionalFeatures\x12&\n\x0ewritingp\
    rogram\x18\x10\x20\x01(\tR\x0ewritingprogram\x12\x16\n\x06source\x18\x11\
    \x20\x01(\tR\x06source\x12B\n\x1dosmosis_replication_timestamp\x18\x20\
    \x20\x01(\x03R\x1bosmosisReplicationTimestamp\x12M\n#osmosis_replication\
    _sequence_number\x18!\x20\x01(\x03R\x20osmosisReplicationSequenceNumber\
    \x12?\n\x1cosmosis_replication_base_url\x18\"\x20\x01(\tR\x19osmosisRepl\
    icationBaseUrl\"`\n\nHeaderBBox\x12\x12\n\x04left\x18\x01\x20\x02(\x12R\
    \x04left\x12\x14\n\x05right\x18\x02\x20\x02(\x12R\x05right\x12\x10\n\x03\
    top\x18\x03\x20\x02(\x12R\x03top\x12\x16\n\x06bottom\x18\x04\x20\x02(\
    \x12R\x06bottom\"\xab\x02\n\x0ePrimitiveBlock\x125\n\x0bstringtable\x18\
    \x01\x20\x02(\x0b2\x13.OSMPBF.StringTableR\x0bstringtable\x12>\n\x0eprim\
    itivegroup\x18\x02\x20\x03(\x0b2\x16.OSMPBF.PrimitiveGroupR\x0eprimitive\
    group\x12'\n\x0bgranularity\x18\x11\x20\x01(\x05:\x03100R\x0bgranularity\
    B\0\x12\"\n\nlat_offset\x18\x13\x20\x01(\x03:\x010R\tlatOffsetB\0\x12\"\
    \n\nlon_offset\x18\x14\x20\x01(\x03:\x010R\tlonOffsetB\0\x121\n\x10date_\
    granularity\x18\x12\x20\x01(\x05:\x041000R\x0fdateGranularityB\0\"\xe2\
    \x01\n\x0ePrimitiveGroup\x12\"\n\x05nodes\x18\x01\x20\x03(\x0b2\x0c.OSMP\
    BF.NodeR\x05nodes\x12(\n\x05dense\x18\x02\x20\x01(\x0b2\x12.OSMPBF.Dense\
    NodesR\x05dense\x12\x1f\n\x04ways\x18\x03\x20\x03(\x0b2\x0b.OSMPBF.WayR\
    \x04ways\x12.\n\trelations\x18\x04\x20\x03(\x0b2\x10.OSMPBF.RelationR\tr\
    elations\x121\n\nchangesets\x18\x05\x20\x03(\x0b2\x11.OSMPBF.ChangeSetR\
    \nchangesets\"\x1b\n\x0bStringTable\x12\x0c\n\x01s\x18\x01\x20\x03(\x0cR\
    \x01s\"\xa9\x01\n\x04Info\x12\x1e\n\x07version\x18\x01\x20\x01(\x05:\x02\
    -1R\x07versionB\0\x12\x1c\n\ttimestamp\x18\x02\x20\x01(\x03R\ttimestamp\
    \x12\x1c\n\tchangeset\x18\x03\x20\x01(\x03R\tchangeset\x12\x10\n\x03uid\
    \x18\x04\x20\x01(\x05R\x03uid\x12\x19\n\x08user_sid\x18\x05\x20\x01(\rR\
    \x07userSid\x12\x18\n\x07visible\x18\x06\x20\x01(\x08R\x07visible\"\xc0\
    \x01\n\tDenseInfo\x12\x1c\n\x07version\x18\x01\x20\x03(\x05R\x07versionB\
    \x02\x10\x01\x12\x20\n\ttimestamp\x18\x02\x20\x03(\x12R\ttimestampB\x02\
    \x10\x01\x12\x20\n\tchangeset\x18\x03\x20\x03(\x12R\tchangesetB\x02\x10\
    \x01\x12\x14\n\x03uid\x18\x04\x20\x03(\x11R\x03uidB\x02\x10\x01\x12\x1d\
    \n\x08user_sid\x18\x05\x20\x03(\x11R\x07userSidB\x02\x10\x01\x12\x1c\n\
    \x07visible\x18\x06\x20\x03(\x08R\x07visibleB\x02\x10\x01\"\x1b\n\tChang\
    eSet\x12\x0e\n\x02id\x18\x01\x20\x02(\x03R\x02id\"\x8c\x01\n\x04Node\x12\
    \x0e\n\x02id\x18\x01\x20\x02(\x12R\x02id\x12\x16\n\x04keys\x18\x02\x20\
    \x03(\rR\x04keysB\x02\x10\x01\x12\x16\n\x04vals\x18\x03\x20\x03(\rR\x04v\
    alsB\x02\x10\x01\x12\x20\n\x04info\x18\x04\x20\x01(\x0b2\x0c.OSMPBF.Info\
    R\x04info\x12\x10\n\x03lat\x18\x08\x20\x02(\x12R\x03lat\x12\x10\n\x03lon\
    \x18\t\x20\x02(\x12R\x03lon\"\x9e\x01\n\nDenseNodes\x12\x12\n\x02id\x18\
    \x01\x20\x03(\x12R\x02idB\x02\x10\x01\x12/\n\tdenseinfo\x18\x05\x20\x01(\
    \x0b2\x11.OSMPBF.DenseInfoR\tdenseinfo\x12\x14\n\x03lat\x18\x08\x20\x03(\
    \x12R\x03latB\x02\x10\x01\x12\x14\n\x03lon\x18\t\x20\x03(\x12R\x03lonB\
    \x02\x10\x01\x12\x1f\n\tkeys_vals\x18\n\x20\x03(\x05R\x08keysValsB\x02\
    \x10\x01\"\xab\x01\n\x03Way\x12\x0e\n\x02id\x18\x01\x20\x02(\x03R\x02id\
    \x12\x16\n\x04keys\x18\x02\x20\x03(\rR\x04keysB\x02\x10\x01\x12\x16\n\
    \x04vals\x18\x03\x20\x03(\rR\x04valsB\x02\x10\x01\x12\x20\n\x04info\x18\
    \x04\x20\x01(\x0b2\x0c.OSMPBF.InfoR\x04info\x12\x16\n\x04refs\x18\x08\
    \x20\x03(\x12R\x04refsB\x02\x10\x01\x12\x14\n\x03lat\x18\t\x20\x03(\x12R\
    \x03latB\x02\x10\x01\x12\x14\n\x03lon\x18\n\x20\x03(\x12R\x03lonB\x02\
    \x10\x01\"\x8f\x02\n\x08Relation\x12\x0e\n\x02id\x18\x01\x20\x02(\x03R\
    \x02id\x12\x16\n\x04keys\x18\x02\x20\x03(\rR\x04keysB\x02\x10\x01\x12\
    \x16\n\x04vals\x18\x03\x20\x03(\rR\x04valsB\x02\x10\x01\x12\x20\n\x04inf\
    o\x18\x04\x20\x01(\x0b2\x0c.OSMPBF.InfoR\x04info\x12\x1f\n\troles_sid\
    \x18\x08\x20\x03(\x05R\x08rolesSidB\x02\x10\x01\x12\x1a\n\x06memids\x18\
    \t\x20\x03(\x12R\x06memidsB\x02\x10\x01\x125\n\x05types\x18\n\x20\x03(\
    \x0e2\x1b.OSMPBF.Relation.MemberTypeR\x05typesB\x02\x10\x01\"-\n\nMember\
    Type\x12\x08\n\x04Node\x10\0\x12\x07\n\x03Way\x10\x01\x12\x0c\n\x08Relat\
    ion\x10\x02B\x0f\n\rcrosby.binaryb\x06proto2\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(12);
            messages.push(HeaderBlock::generated_message_descriptor_data());
            messages.push(HeaderBBox::generated_message_descriptor_data());
            messages.push(PrimitiveBlock::generated_message_descriptor_data());
            messages.push(PrimitiveGroup::generated_message_descriptor_data());
            messages.push(StringTable::generated_message_descriptor_data());
            messages.push(Info::generated_message_descriptor_data());
            messages.push(DenseInfo::generated_message_descriptor_data());
            messages.push(ChangeSet::generated_message_descriptor_data());
            messages.push(Node::generated_message_descriptor_data());
            messages.push(DenseNodes::generated_message_descriptor_data());
            messages.push(Way::generated_message_descriptor_data());
            messages.push(Relation::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(relation::MemberType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
